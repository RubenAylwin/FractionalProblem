#ifndef DISCRETE_MESH_TEST
#define DISCRETE_MESH_TEST
/*
 *TESTS FOR DISCRETE SPACES
 */
#include <Utilities.h>
#include <DiscreteSpaceMesh.h>
#include <Curve.h>
#include <vector>
#include <complex>
#include <boost/test/execution_monitor.hpp>
#include <cmath>
#include <stdexcept>
#include <Utilities.h>
#include <OneDimensionalIntegration.h>
#include <TwoDimensionalIntegration.h>
#include <DiscreteSpaceMatrixMgr.h>
#include <Mesh.h>
#include <RegularP0Mesh.h>
namespace discreteMeshTests{

    static double tolerance = 1E-9;

    BOOST_AUTO_TEST_SUITE(DiscreteMesh)

    /*
     *TEST FOR MESH
     */

    BOOST_AUTO_TEST_SUITE(Mesh)
    BOOST_AUTO_TEST_CASE(ConstructorTest)
    {
        msg(1) << "start Discrete::MESH::ConstructorTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);
        msg(1) << "end Discrete::MESH::ConstructorTest" << endMsg;
    }

    BOOST_AUTO_TEST_CASE(ElementTest)
    {
        msg(1) << "start Discrete::MESH::ElementTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);

        for (int i = 0; i < 10; ++i){
            BOOST_CHECK_CLOSE(mesh.getElement(i).getA().getX(), i/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getA().getY(), 0.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getB().getX(), (i+1.)/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getB().getY(), 0.0, tolerance);
        }
        
        msg(1) << "end Discrete::MESH::ElementTest" << endMsg;
    }

    BOOST_AUTO_TEST_CASE(ElementTest2)
    {
        msg(1) << "start Discrete::MESH::ElementTest2" << endMsg;
        StraightCurve curve(2.87);
        MeshCurve1D mesh(10, curve);

        for (int i = 0; i < 10; ++i){
            BOOST_CHECK_CLOSE(mesh.getElement(i).getA().getX(), 2.87*i/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getA().getY(), 0.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getB().getX(), 2.87*(i+1.)/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i).getB().getY(), 0.0, tolerance);
        }
        
        msg(1) << "end Discrete::MESH::ElementTest2" << endMsg;
    }


    BOOST_AUTO_TEST_CASE(ElementEvaluationTest)
    {
        msg(1) << "start Discrete::MESH::ElementEvaluationTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);

        for (int i = 0; i < 10; ++i){
            BOOST_CHECK_CLOSE(mesh.getElement(i)(0.0).getX(), i/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i)(0.0).getY(), 0.0, tolerance);

            BOOST_CHECK_CLOSE(mesh.getElement(i)(0.5).getX(), (i+0.5)/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i)(0.5).getY(), 0.0, tolerance);
            
            BOOST_CHECK_CLOSE(mesh.getElement(i)(1.0).getX(), (i+1)/10.0, tolerance);
            BOOST_CHECK_CLOSE(mesh.getElement(i)(1.0).getY(), 0.0, tolerance);

        }
        
        msg(1) << "end Discrete::MESH::ElementEvaluationTest" << endMsg;
    }

    
    BOOST_AUTO_TEST_SUITE_END()
    
    /*
     *TEST FOR P0 SPACE
     */
    BOOST_AUTO_TEST_SUITE(P0)

    BOOST_AUTO_TEST_CASE(ConstructorTest)
    {
        msg(1) << "start Discrete::P0::ConstructorTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);
        RegularP0Mesh_1D regular(mesh);
        msg(1) << "end Discrete::P0::ConstructorTest" << endMsg;
    }

    
    BOOST_AUTO_TEST_CASE(EvaluationTest)
    {
        msg(1) << "start Discrete::P0::EvaluationTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);
        RegularP0Mesh_1D space(mesh);

        auto &firstFun = space.basisFunction(0);
        BOOST_CHECK_CLOSE(1, firstFun(0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(1, firstFun(0.15).real(), tolerance);

        auto &lastFun = space.basisFunction(9);
        BOOST_CHECK_CLOSE(1, lastFun(0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(1, lastFun(0.95).real(), tolerance);
        msg(1) << "end Discrete::P0::EvaluationTest" << endMsg;
    }

    
    BOOST_AUTO_TEST_CASE(EvaluationMeshTest)
    {
        msg(1) << "start Discrete::P0::EvaluationTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);
        RegularP0Mesh_1D space(mesh);

        auto &firstFun = space.basisFunction(0);
        BOOST_CHECK_CLOSE(1, firstFun.evaluate(0, 0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(1, firstFun.evaluate(0, 0.15).real(), tolerance);
        BOOST_CHECK_CLOSE(0, firstFun.evaluate(2, 0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(0, firstFun.evaluate(3, 0.15).real(), tolerance);

        auto &lastFun = space.basisFunction(9);
        BOOST_CHECK_CLOSE(1, lastFun.evaluate(9, 0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(1, lastFun.evaluate(9, 0.95).real(), tolerance);
        BOOST_CHECK_CLOSE(0, lastFun.evaluate(6, 0.05).real(), tolerance);
        BOOST_CHECK_CLOSE(0, lastFun.evaluate(6, 0.95).real(), tolerance);

        msg(1) << "end Discrete::P0::EvaluationTest" << endMsg;
    }

    
    BOOST_AUTO_TEST_CASE(InvalidFunctionTest)
    {
        msg(1) << "start Discrete::P0::InvalidFunctionTest" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(10, curve);
        RegularP0Mesh_1D space(mesh);

        BOOST_REQUIRE_THROW(space.basisFunction(10), std::invalid_argument);
        msg(1) << "end Discrete::P0::InvalidFunctionTest" << endMsg;
    }

    BOOST_AUTO_TEST_CASE(TestingConstantFunction)
    {
        msg(1) << "start Discrete::P0::TestingConstantFunction" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(20, curve);
        RegularP0Mesh_1D space(mesh);

        ExplicitScalarFunction_2D function([&](double t, double s){ return 1. + 0*s;});
        auto testingResult = space.testAgainstBasis(function);
        
        for (const auto val : testingResult) {
            BOOST_CHECK_CLOSE(val.real(), 1.0/20, tolerance);
        }
        msg(1) << "end Discrete::P0::TestingConstantFunction" << endMsg;
    }

    BOOST_AUTO_TEST_CASE(TestingPiecewiseConstantFunction)
    {
        msg(1) << "start Discrete::P0::TestingPiecewiseConstantFunction" << endMsg;
        StraightCurve curve(1);
        MeshCurve1D mesh(20, curve);
        RegularP0Mesh_1D space(mesh);

        ExplicitScalarFunction_2D function([&](double t, double s){ return t > 0.5 ?  10 : 1;});
        auto testingResult = space.testAgainstBasis(function);
        
        for (unsigned i = 0; i < 10; ++i) {
            BOOST_CHECK_CLOSE(testingResult[i].real(), 1.0/20, tolerance);
        }

        for (unsigned i = 10; i < 20; ++i) {
            BOOST_CHECK_CLOSE(testingResult[i].real(), 0.5, tolerance);
        }

        msg(1) << "end Discrete::P0::TestingPiecewiseConstantFunction" << endMsg;
    }
    
    BOOST_AUTO_TEST_SUITE_END()

    BOOST_AUTO_TEST_SUITE_END()
}
#endif
