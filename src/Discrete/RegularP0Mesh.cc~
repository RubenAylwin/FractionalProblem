#include <algorithm>
#include <cassert>
#include <cmath>
#include <stdexcept>
#include <iostream>
#include <ScalarValuedFunction.h>
#include <OneDimensionalIntegration.h>
#include <TwoDimensionalIntegration.h>
#include <MyTypes.h>
#include <Utilities.h>
#include <Msg.h>
#include <Mesh.h>
#include <RegularP0Mesh.h>

useMessages("REG_MESH_P0");
/**
 * @brief: Constructor
 */
RegularP0Mesh_1D::RegularP0Mesh_1D(const Mesh1D &mesh) :
    DiscreteSpaceMesh(mesh),
    _size{_mesh.numElements()}
{
    _integrator1D.reset(new GaussLegendre_1D(8));
    _integrator2D.reset(new GaussLegendre_2D<5, 5>());
}

/**
 * @brief: Destructor
 */
RegularP0Mesh_1D::~RegularP0Mesh_1D(void)
{
}

BEM::Complex RegularP0Mesh_1D::testAgainstBaseElement(const ScalarFunctionBase_2D &function, unsigned globalNumber) const
{
    auto &basis = basisFunction(globalNumber);
    auto &element = _mesh.getElement(globalNumber);
    double jacobian = element.getSize();
    ExplicitScalarFunction_1D integrand([&basis, &function, &element, jacobian](double t) {
        return jacobian*basis(t)*function(element(t).getX(), element(t).getY());
    });
    return _integrator1D->integrate(0, 1, integrand);
}


/**
 * @brief: Given a coefficient vector return the associated discrete function.
 * This is the only way to generate a discretization/construct a discrete function.
 */
std::unique_ptr<DiscreteFunctionMesh> RegularP0Mesh_1D::generateFunction(const std::vector<BEM::Complex> coefficients) const
{
    return std::unique_ptr<DiscreteFunctionMesh>(new P0Function(_mesh, coefficients));
}


/**
 * @brief: Returns the i-th basis function.
 */
/*TODO: CONSIDER RETURNING POINTER TO SCALARFUNCTIONBASE_1D*/
const BasisFunctionMesh &RegularP0Mesh_1D::basisFunction(const unsigned globalNumber) const
{
    // Check numbering. Throw exception if out of bounds.
    if (not (globalNumber < _mesh.numElements() and globalNumber >= 0)) {
        throw std::invalid_argument("Invalid basis index (out of bounds)");
    }

    std::lock_guard<std::mutex> lock(_basisMutex);
    if (_basis.find(globalNumber) == _basis.end()) {
        // Fill in coefficient vector
        std::vector<BEM::Complex> coefficients(_mesh.numElements(), std::complex(0.0, 0.0));

        // Coef = 1 for the corresponding basis
        coefficients[globalNumber] = std::complex(1.0, 0.0);

        // Return unique ptr
        _basis.insert({globalNumber ,std::unique_ptr<BasisFunctionMesh>(new BasisFunction(_mesh, globalNumber))});
    }
    return *(_basis.at(globalNumber));
}


/*
 * Code for the discrete P0 functions.
 */

/**
 * @brief: Construct a discrete function from given coefficients.
 */
RegularP0Mesh_1D::P0Function::P0Function(const Mesh1D &mesh, const std::vector<BEM::Complex> coefficients) :
    DiscreteFunctionMesh(mesh),
    _coefficients{coefficients}
{
    for (unsigned i = 0; i < _coefficients.size(); ++i) {
        auto &val = _coefficients[i];
        if (std::abs(val) > 1E-9) {
            _support.push_back(i);
        }
    }
    assert(_coefficients.size() == _mesh.numElements());
}


BEM::Complex RegularP0Mesh_1D::P0Function::evaluate(unsigned elementIndex, [[maybe_unused]]double t) const
{
    assert(elementIndex < _mesh.numElements() and elementIndex >= 0);
    return _coefficients[elementIndex];
}

RegularP0Mesh_1D::BasisFunction::BasisFunction(const Mesh1D &mesh, unsigned index) :
    DiscreteFunctionMesh(mesh),
    BasisFunctionMesh(mesh),
    P0Function(mesh, BEM::basisVector(index, mesh.numElements()))
{
}


BEM::Complex RegularP0Mesh_1D::BasisFunction::operator()([[maybe_unused]]double t) const
{
    return 1.0;
}


/**
 * @brief: return a function evaluating then derivative of the corresponding function. 
 */
ScalarFunctionBase_1D *RegularP0Mesh_1D::BasisFunction::derivative(void) const
{
    std::lock_guard<std::mutex> lock(_derMutex);
    if (not _derivative) {
        auto derivative = [](double t) -> BEM::Complex {
            return t*0.0;
        };
        _derivative.reset(new ExplicitScalarFunction_1D(derivative));
    }
    return _derivative.get();
}

/**
 * @brief: return a function evaluating the anti-derivative of the corresponding function. First corresponds
 * to the point of evaluation, second one to constant (since derivative of constant is 0).
 */
ScalarFunctionBase_2D *RegularP0Mesh_1D::BasisFunction::antiDerivative(void) const
{
    std::lock_guard<std::mutex> lock(_derMutex);
    if (not _antiDerivative) {
        auto antiDerivative = [&] (double t, double s) -> BEM::Complex {
            // Check for correct range (TODO: THIS SHOULD BE A THROW) rate
            assert(t >= 0 and t <= 1);
            return (t + s);
        };
        _antiDerivative.reset(new ExplicitScalarFunction_2D(antiDerivative));
    }
    return _antiDerivative.get();
}
