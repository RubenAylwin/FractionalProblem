t d;
int j;
double *prime_inv;
double *r;
int *t;

prime_inv = new double[m];
r = new double[m];
t = new int[m];

for ( j = 0; j < m; j++ )
    {
        t[j] = i;
    }
//
//  Carry out the computation.
//
for ( j = 0; j < m; j++ )
    {
        prime_inv[j] = 1.0 / ( double ) ( prime ( j + 1 ) );
    }

for ( j = 0; j < m; j++ )
    {
        r[j] = 0.0;
    }

while ( 0 < i4vec_sum ( m, t ) )
    {
        for ( j = 0; j < m; j++ )
            {
                d = ( t[j] % prime ( j + 1 ) );
                r[j] = r[j] + ( double ) ( d ) * prime_inv[j];
                prime_inv[j] = prime_inv[j] / ( double ) ( prime ( j + 1 ) );
                t[j] = ( t[j] / prime ( j + 1 ) );
            }
    }

delete [] prime_inv;
delete [] t;

return r;
}
//****************************************************************************80

double *halton_base ( int i, int m, int b[] )

//****************************************************************************80
//
//  Purpose:
//
//    HALTON_BASE computes an element of a Halton sequence with user bases.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    12 August 2016
//
//  Author:
//
//    John Burkardt
//
//  Reference:
//
//    John Halton,
//    On the efficiency of certain quasi-random sequences of points
//    in evaluating multi-dimensional integrals,
//    Numerische Mathematik,
//    Volume 2, pages 84-90, 1960.
//
//  Parameters:
//
//    Input, int I, the index of the element of the sequence.
//    0 <= I.
//
//    Input, int M, the spatial dimension.
//
//    Input, int B[M], the bases to use for each dimension.
//
//    Output, double HALTON_BASE[M], the element of the sequence with index I.
//
{
    double *b_inv;
    int d;
    int j;
    double *r;
    int *t;

    b_inv = new double[m];
    r = new double[m];
    t = new int[m];

    for ( j = 0; j < m; j++ )
        {
            t[j] = i;
        }
    //
    //  Carry out the computation.
    //
    for ( j = 0; j < m; j++ )
        {
            b_inv[j] = 1.0 / ( double ) ( b[j] );
        }

    for ( j = 0; j < m; j++ )
        {
            r[j] = 0.0;
        }

    while ( 0 < i4vec_sum ( m, t ) )
        {
            for ( j = 0; j < m; j++ )
                {
                    d = ( t[j] % b[j] );
                    r[j] = r[j] + ( double ) ( d ) * b_inv[j];
                    b_inv[j] = b_inv[j] / ( double ) ( b[j] );
                    t[j] = ( t[j] / b[j] );
                }
        }

    delete [] b_inv;
    delete [] t;

    return r;
}
//****************************************************************************80

int halton_inverse ( double r[], int m )

//****************************************************************************80
//
//  Purpose:
//
//    HALTON_INVERSE inverts an element of the Halton sequence.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    12 August 2016
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, double R[M], the I-th element of the Halton sequence.
//    0 <= R < 1.0
//
//    Input, int M, the spatial dimension.
//
//    Output, int HALTON_INVERSE, the index of the element of the sequence.
//
{
    int d;
    int i;
    int j;
    int p;
    double t;

    for ( j = 0; j < m; j++ )
        {
            if ( r[j] < 0.0 || 1.0 <= r[j] )
                {
                    cerr << "\n";
                    cerr << "HALTON_INVERSE - Fatal error\n";
                    cerr << "  0 <= R < 1.0 is required.\n";
                    exit ( 1 );
                }
        }
    //
    //  Invert using the first component only, because working with base
    //  2 is accurate.
    //
    i = 0;
    t = r[0];
    p = 1;

    while ( t != 0.0 )
        {
            t = t * 2.0;
            d = ( int ) ( t );
            i = i + d * p;
            p = p * 2;
            t = r8_mod ( t, 1.0 );
        }

    return i;
}
//****************************************************************************80

double *halton_sequence ( int i1, int i2, int m )

//****************************************************************************80
//
//  Purpose:
//
//    HALTON_SEQUENCE computes elements I1 through I2 of a Halton sequence.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    19 August 2016
//
//  Author:
//
//    John Burkardt
//
//  Reference:
//
//    John Halton,
//    On the efficiency of certain quasi-random sequences of points
//    in evaluating multi-dimensional integrals,
//    Numerische Mathematik,
//    Volume 2, pages 84-90, 1960.
//
//  Parameters:
//
//    Input, int I1, I2, the indices of the first and last
//    elements of the sequence.  0 <= I1, I2.
//
//    Input, int M, the spatial dimension.
//    1 <= M <= 100.
//
//    Output, double HALTON_SEQUENCE[M*(abs(I1-I2)+1)], the elements of the
//    sequence with indices I1 through I2.
//
{
    int d;
    int i;
    int i3;
    int j;
    int k;
    int n;
    double *prime_inv;
    double *r;
    int *t;

    prime_inv = new double[m];
    r = new double[m*(abs(i1-i2)+1)];
    t = new int[m];

    if ( i1 <= i2 )
        {
            i3 = +1;
        }
    else
        {
            i3 = -1;
        }

    n = abs ( i2 - i1 ) + 1;

    for ( j = 0; j < n; j++ )
        {
            for ( i = 0; i < m; i++ )
                {
                    r[i+j*m] = 0.0;
                }
        }

    i = i1;

    for ( k = 0; k < n; k++ )
        {
            for ( j = 0; j < m; j++ )
                {
                    t[j] = i;
                }
            //
            //  Carry out the computation.
            //
            for ( j = 0; j < m; j++ )
                {
                    prime_inv[j] = 1.0 / ( double ) ( prime ( j + 1 ) );
                }

            while ( 0 < i4vec_sum ( m, t ) )
                {
                    for ( j = 0; j < m; j++ )
                        {
                            d = ( t[j] % prime ( j + 1 ) );
                            r[j+k*m] = r[j+k*m] + ( double ) ( d ) * prime_inv[j];
                            prime_inv[j] = prime_inv[j] / ( double ) ( prime ( j + 1 ) );
                            t[j] = ( t[j] / prime ( j + 1 ) );
                        }
                }
            i = i + i3;
        }

    delete [] prime_inv;
    delete [] t;

    return r;
}
//****************************************************************************80

int i4vec_sum ( int n, int a[] )

//****************************************************************************80
//
//  Purpose:
//
//    I4VEC_SUM sums the entries of an I4VEC.
//
//  Discussion:
//
//    An I4VEC is a vector of I4's.
//
//  Example:
//
//    Input:
//
//      A = ( 1, 2, 3, 4 )
//
//    Output:
//
//      I4VEC_SUM = 10
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    26 May 1999
//
//  Author:
//
//    John Burkardt
//
//  Parameters:
//
//    Input, int N, the number of entries in the vector.
//
//    Input, int A[N], the vector to be summed.
//
//    Output, int I4VEC_SUM, the sum of the entries of A.
//
{
    int i;
    int sum;

    sum = 0;
    for ( i = 0; i < n; i++ )
        {
            sum = sum + a[i];
        }

    return sum;
}
//****************************************************************************80

int prime ( int n )

//****************************************************************************80
//
//  Purpose:
//
//    PRIME returns any of the first PRIME_MAX prime numbers.
//
//  Discussion:
//
//    PRIME_MAX is 1600, and the largest prime stored is 13499.
//
//    Thanks to Bart Vandewoestyne for pointing out a typo, 18 February 2005.
//
//  Licensing:
//
//    This code is distributed under the GNU LGPL license.
//
//  Modified:
//
//    18 February 2005
//
//  Author:
//
//    John Burkardt
//
//  Reference:
//
//    Milton Abramowitz, Irene Stegun,
//    Handbook of Mathematical Functions,
//    National Bureau of Standards, 1964,
//    ISBN: 0-486-61272-4,
//    LC: QA47.A34.
//
//    Daniel Zwillinger,
//    CRC Standard Mathematical Tables and Formulae,
//    30th Edition,
//    CRC Press, 1996, pages 95-98.
//
//  Parameters:
//
//    Input, int N, the index of the desired prime number.
//    In general, is should be true that 0 <= N <= PRIME_MAX.
//    N = -1 returns PRIME_MAX, the index of the largest prime available.
//    N = 0 is legal, returning PRIME = 1.
//
//    Output, int PRIME, the N-th prime.  If N is out of range, PRIME
//    is returned as -1.
//
{
    # define PRIME_MAX 1600

    int npvec[PRIME_MAX] = {
        2,    3,    5,    7,   11,   13,   17,   19,   23,   29,
        31,   37,   41,   43,   47,   53,   59,   61,   67,   71,
        73,   79,   83,   89,   97,  101,  103,  107,  109,  113,
        127,  131,  137,  139,  149,  151,  157,  163,  167,  173,
        179,  181,  191,  193,  197,  199,  211,  223,  227,  229,
        233,  239,  241,  251,  257,  263,  269,  271,  277,  281,
        283,  293,  307,  311,  313,  317,  331,  337,  347,  349,
        353,  359,  367,  373,  379,  383,  389,  397,  401,  409,
        419,  421,  431,  433,  439,  443,  449,  457,  461,  463,
        467,  479,  487,  491,  499,  503,  509,  521,  523,  541,
        547,  557,  563,  569,  571,  577,  587,  593,  599,  601,
        607,  613,  617,  619,  631,  641,  643,  647,  653,  659,
        661,  673,  677,  683,  691,  701,  709,  719,  727,  733,
        739,  743,  751,  757,  761,  769,  773,  787,  797,  809,
        811,  821,  823,  827,  829,  839,  853,  857,  859,  863,
        877,  881,  883,  887,  907,  911,  919,  929,  937,  941,
        947,  953,  967,  971,  977,  983,  991,  997, 1009, 1013,
        1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069,
        1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151,
        1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223,
        1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291,
        1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373,
        1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451,
        1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511,
        1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583,
        1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657,
        1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733,
        1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811,
        1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889,
        1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987,
        1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053,
        2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129,
        2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213,
        2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,
        2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357,
        2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423,
        2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531,
        2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617,
        2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687,
        2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741,
        2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819,
        2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903,
        2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999,
        3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079,
        3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181,
        3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257,
        3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331,
        3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413,
        3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511,
        3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571,
        3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643,
        3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727,
        3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821,
        3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907,
        3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989,
        4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057,
        4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139,
        4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231,
        4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297,
        4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409,
        4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493,
        4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583,
        4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657,
        4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751,
        4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831,
        4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937,
        4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999,